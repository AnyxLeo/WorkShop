{"id":"../node_modules/tubular-common/dist/Transformer.js","dependencies":[{"name":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\dist\\Transformer.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\src\\Transformer.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\package.json","includedInParent":true,"mtime":1567469419529},{"name":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\package.json","includedInParent":true,"mtime":1567480635442},{"name":"./date-utils","loc":{"line":3,"column":27},"parent":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\dist\\Transformer.js","resolved":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\dist\\date-utils.js"},{"name":"./Models","loc":{"line":4,"column":23},"parent":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\dist\\Transformer.js","resolved":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\dist\\Models\\index.js"},{"name":"./Models/GridResponse","loc":{"line":5,"column":29},"parent":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\dist\\Transformer.js","resolved":"C:\\Users\\Anyx\\Documents\\Unosquare\\Tubular\\Tubular.Web\\client-app\\node_modules\\tubular-common\\dist\\Models\\GridResponse.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar date_utils_1 = require(\"./date-utils\");\r\nvar Models_1 = require(\"./Models\");\r\nvar GridResponse_1 = require(\"./Models/GridResponse\");\r\nvar isEqual = function (date1, date2) { return date_utils_1.default(date1).getTime() === date_utils_1.default(date2).getTime(); };\r\nvar isAfter = function (date1, date2) { return date_utils_1.default(date1).getTime() > date_utils_1.default(date2).getTime(); };\r\nvar isBefore = function (date1, date2) { return date_utils_1.default(date1).getTime() < date_utils_1.default(date2).getTime(); };\r\nvar Transformer = /** @class */ (function () {\r\n    function Transformer() {\r\n    }\r\n    Transformer.getResponse = function (request, dataSource) {\r\n        var _this = this;\r\n        var response = new GridResponse_1.default(request.Counter);\r\n        response.TotalRecordCount = dataSource.length;\r\n        var data = this.applyFreeTextSearch(request, dataSource);\r\n        data = this.applyFiltering(request, data);\r\n        data = this.applySorting(request, data);\r\n        response.FilteredRecordCount = data.length;\r\n        if (request.Take > -1) {\r\n            response.TotalPages = Math.ceil(response.FilteredRecordCount / request.Take);\r\n            if (response.TotalPages > 0) {\r\n                response.CurrentPage = request.Skip / request.Take + 1;\r\n            }\r\n        }\r\n        response.AggregationPayload = this.getAggregatePayload(request, data);\r\n        response.Payload = data\r\n            .slice(request.Skip, request.Skip + request.Take)\r\n            .map(function (row) { return _this.parsePayload(row, request.Columns); });\r\n        return response;\r\n    };\r\n    Transformer.applyFreeTextSearch = function (request, subset) {\r\n        if (request.Search && request.Search.Operator.toLowerCase() === Models_1.CompareOperators.AUTO.toLowerCase()) {\r\n            var searchableColumns_1 = request.Columns.filter(function (x) { return x.Searchable; });\r\n            if (searchableColumns_1.length > 0) {\r\n                var filter_1 = request.Search.Text.toLowerCase();\r\n                if (filter_1 === '') {\r\n                    return subset;\r\n                }\r\n                return subset.filter(function (item) {\r\n                    return searchableColumns_1.some(function (x) {\r\n                        if (typeof item[x.Name] === 'undefined') {\r\n                            return false;\r\n                        }\r\n                        else {\r\n                            return item[x.Name].toLowerCase().indexOf(filter_1) > -1;\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            return subset;\r\n        }\r\n    };\r\n    Transformer.applyFiltering = function (request, subset) {\r\n        request.Columns\r\n            .filter(function (column) { return column.hasFilter; })\r\n            .forEach(function (column) {\r\n            var isDate = column.DataType === 'datetime' ||\r\n                column.DataType === 'date' ||\r\n                column.DataType === 'datetimeutc';\r\n            var partialfiltering = function (data, action) { return data.filter(function (row) { return typeof row[column.Name] === 'undefined' || row[column.Name] === null\r\n                ? false\r\n                : action(row[column.Name]); }); };\r\n            switch (column.Filter.Operator) {\r\n                case Models_1.CompareOperators.EQUALS:\r\n                    if (isDate) {\r\n                        subset = subset.filter(function (row) {\r\n                            return isEqual(row[column.Name], column.Filter.Text);\r\n                        });\r\n                    }\r\n                    else if (column.DataType === 'string') {\r\n                        subset = partialfiltering(subset, function (x) { return x.toLowerCase() === column.Filter.Text.toLowerCase(); });\r\n                    }\r\n                    else {\r\n                        subset = subset.filter(function (row) {\r\n                            return row[column.Name] === column.Filter.Text;\r\n                        });\r\n                    }\r\n                    break;\r\n                case Models_1.CompareOperators.NOT_EQUALS:\r\n                    if (column.DataType === 'string') {\r\n                        subset = partialfiltering(subset, function (x) { return x.toLowerCase() !== column.Filter.Text.toLowerCase(); });\r\n                    }\r\n                    else {\r\n                        subset = subset.filter(function (row) {\r\n                            return row[column.Name] !== column.Filter.Text;\r\n                        });\r\n                    }\r\n                    break;\r\n                case Models_1.CompareOperators.CONTAINS:\r\n                    subset = partialfiltering(subset, function (x) { return x.toLowerCase()\r\n                        .indexOf(column.Filter.Text.toLowerCase()) >= 0; });\r\n                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().indexOf(column.Filter.Text.toLowerCase()) >= 0; });\r\n                    break;\r\n                case Models_1.CompareOperators.NOT_CONTAINS:\r\n                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().indexOf(column.Filter.Text.toLowerCase()) < 0; });\r\n                    break;\r\n                case Models_1.CompareOperators.STARTS_WITH:\r\n                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().startsWith(column.Filter.Text.toLowerCase()); });\r\n                    break;\r\n                case Models_1.CompareOperators.NOT_STARTS_WITH:\r\n                    subset = partialfiltering(subset, function (x) { return !x.toLowerCase().startsWith(column.Filter.Text.toLowerCase()); });\r\n                    break;\r\n                case Models_1.CompareOperators.ENDS_WITH:\r\n                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().endsWith(column.Filter.Text.toLowerCase()); });\r\n                case Models_1.CompareOperators.NOT_ENDS_WITH:\r\n                    subset = partialfiltering(subset, function (x) { return !x.toLowerCase().endsWith(column.Filter.Text.toLowerCase()); });\r\n                    break;\r\n                case Models_1.CompareOperators.GT:\r\n                    if (isDate) {\r\n                        subset = subset.filter(function (row) {\r\n                            return isAfter(row[column.Name], column.Filter.Text);\r\n                        });\r\n                    }\r\n                    else {\r\n                        subset = subset.filter(function (row) { return row[column.Name] > column.Filter.Text; });\r\n                    }\r\n                    break;\r\n                case Models_1.CompareOperators.GTE:\r\n                    if (isDate) {\r\n                        subset = subset.filter(function (row) {\r\n                            return isEqual(row[column.Name], column.Filter.Text)\r\n                                || isAfter(row[column.Name], column.Filter.Text);\r\n                        });\r\n                    }\r\n                    else {\r\n                        subset = subset.filter(function (row) { return row[column.Name] >= column.Filter.Text; });\r\n                    }\r\n                    break;\r\n                case Models_1.CompareOperators.LT:\r\n                    if (isDate) {\r\n                        subset = subset.filter(function (row) {\r\n                            return isBefore(row[column.Name], column.Filter.Text);\r\n                        });\r\n                    }\r\n                    else {\r\n                        subset = subset.filter(function (row) { return row[column.Name] < column.Filter.Text; });\r\n                    }\r\n                    break;\r\n                case Models_1.CompareOperators.LTE:\r\n                    if (isDate) {\r\n                        subset = subset.filter(function (row) {\r\n                            return isEqual(row[column.Name], column.Filter.Text)\r\n                                || isBefore(row[column.Name], column.Filter.Text);\r\n                        });\r\n                    }\r\n                    else {\r\n                        subset = subset.filter(function (row) { return row[column.Name] <= column.Filter.Text; });\r\n                    }\r\n                    break;\r\n                case Models_1.CompareOperators.BETWEEN:\r\n                    if (isDate) {\r\n                        subset = subset.filter(function (row) {\r\n                            return (isEqual(row[column.Name], column.Filter.Text)\r\n                                || isAfter(row[column.Name], column.Filter.Text)) &&\r\n                                (isEqual(row[column.Name], column.Filter.Argument[0])\r\n                                    || isBefore(row[column.Name], column.Filter.Argument[0]));\r\n                        });\r\n                    }\r\n                    else {\r\n                        subset = subset.filter(function (row) { return row[column.Name] >= column.Filter.Text &&\r\n                            row[column.Name] <= column.Filter.Argument[0]; });\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new Error('Unsupported Compare Operator');\r\n            }\r\n        });\r\n        return subset;\r\n    };\r\n    Transformer.applySorting = function (request, subset) {\r\n        var sortedColumns = request.Columns\r\n            .filter(function (column) { return column.SortOrder > 0; });\r\n        var sorts = [\r\n            { Name: request.Columns[0].Name, Asc: true }\r\n        ];\r\n        if (sortedColumns.length > 0) {\r\n            sortedColumns.sort(function (a, b) { return a.SortOrder > b.SortOrder ? 1 : b.SortOrder > a.SortOrder ? -1 : 0; });\r\n            sorts = sortedColumns\r\n                .map(function (y) { return ({ Name: y.Name, Asc: y.SortDirection === Models_1.ColumnSortDirection.ASCENDING }); });\r\n        }\r\n        subset.sort(function (a, b) {\r\n            var result = 0;\r\n            for (var _i = 0, sorts_1 = sorts; _i < sorts_1.length; _i++) {\r\n                var current = sorts_1[_i];\r\n                var reverse = current.Asc ? 1 : -1;\r\n                if (typeof a[current.Name] === 'undefined' || typeof b[current.Name] === 'undefined') {\r\n                    result = reverse * -1;\r\n                    break;\r\n                }\r\n                if (a[current.Name] < b[current.Name]) {\r\n                    result = reverse * -1;\r\n                    break;\r\n                }\r\n                if (a[current.Name] > b[current.Name]) {\r\n                    result = reverse * 1;\r\n                    break;\r\n                }\r\n            }\r\n            return result;\r\n        });\r\n        return subset;\r\n    };\r\n    Transformer.getAggregatePayload = function (request, subset) {\r\n        var aggregateColumns = request.Columns\r\n            .filter(function (column) {\r\n            return column.Aggregate && column.Aggregate.toLowerCase() !== Models_1.AggregateFunctions.NONE.toLowerCase();\r\n        });\r\n        return aggregateColumns.reduce(function (prev, column) {\r\n            switch (column.Aggregate.toLowerCase()) {\r\n                case Models_1.AggregateFunctions.SUM.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0\r\n                        ? 0\r\n                        : subset.reduce(function (sum, r) { return typeof r[column.Name] === 'undefined'\r\n                            ? sum\r\n                            : sum + r[column.Name]; }, 0);\r\n                    break;\r\n                case Models_1.AggregateFunctions.AVERAGE.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0\r\n                        ? 0\r\n                        : subset.reduce(function (sum, r) { return typeof r[column.Name] === 'undefined'\r\n                            ? sum\r\n                            : sum + r[column.Name]; }, 0)\r\n                            / subset.length;\r\n                    break;\r\n                case Models_1.AggregateFunctions.MAX.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0 ? 0\r\n                        : subset.reduce(function (max, r) { return r[column.Name] > max ? r[column.Name] : max; }, subset[0][column.Name]);\r\n                    break;\r\n                case Models_1.AggregateFunctions.MIN.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0 ? 0\r\n                        : subset.reduce(function (min, r) { return r[column.Name] < min ? r[column.Name] : min; }, subset[0][column.Name]);\r\n                    break;\r\n                case Models_1.AggregateFunctions.COUNT.toLowerCase():\r\n                    prev[column.Name] = subset.length;\r\n                    break;\r\n                case Models_1.AggregateFunctions.DISTINCT_COUNT.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0 ? 0\r\n                        : subset.reduce(function (list, r) {\r\n                            if (list.indexOf(r[column.Name]) === -1) {\r\n                                list.push(r[column.Name]);\r\n                            }\r\n                            return list;\r\n                        }, []).length;\r\n                    break;\r\n                default:\r\n                    throw new Error('Unsupported aggregate function');\r\n            }\r\n            return prev;\r\n        }, {});\r\n    };\r\n    Transformer.parsePayload = function (row, columns) {\r\n        return columns.reduce(function (obj, column, key) {\r\n            obj[column.Name] = row[key] || row[column.Name];\r\n            return obj;\r\n        }, {});\r\n    };\r\n    return Transformer;\r\n}());\r\nexports.default = Transformer;\r\n"},"sourceMaps":{"js":{"version":3,"file":"Transformer.js","sourceRoot":"","sources":["../src/Transformer.ts"],"names":[],"mappings":"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","sourcesContent":["import toDate from './date-utils';\r\nimport {\r\n    AggregateFunctions, ColumnSortDirection,\r\n    CompareOperators\r\n} from './Models';\r\nimport ColumnModel from './Models/ColumnModel';\r\nimport GridRequest from './Models/GridRequest';\r\nimport GridResponse from './Models/GridResponse';\r\n\r\nconst isEqual = (date1: any, date2: any) => toDate(date1).getTime() === toDate(date2).getTime();\r\nconst isAfter = (date1: any, date2: any) => toDate(date1).getTime() > toDate(date2).getTime();\r\nconst isBefore = (date1: any, date2: any) => toDate(date1).getTime() < toDate(date2).getTime();\r\n\r\nexport default class Transformer {\r\n\r\n    public static getResponse(request: GridRequest, dataSource: any): GridResponse {\r\n        const response = new GridResponse(request.Counter);\r\n        response.TotalRecordCount = dataSource.length;\r\n\r\n        let data = this.applyFreeTextSearch(request, dataSource);\r\n        data = this.applyFiltering(request, data);\r\n        data = this.applySorting(request, data);\r\n\r\n        response.FilteredRecordCount = data.length;\r\n\r\n        if (request.Take > -1) {\r\n            response.TotalPages = Math.ceil(response.FilteredRecordCount / request.Take);\r\n\r\n            if (response.TotalPages > 0) {\r\n                response.CurrentPage = request.Skip / request.Take + 1;\r\n            }\r\n        }\r\n\r\n        response.AggregationPayload = this.getAggregatePayload(request, data);\r\n\r\n        response.Payload = data\r\n            .slice(request.Skip, request.Skip + request.Take)\r\n            .map((row: any) => this.parsePayload(row, request.Columns));\r\n\r\n        return response;\r\n    }\r\n\r\n    private static applyFreeTextSearch(request: GridRequest, subset: any[]) {\r\n        if (request.Search && request.Search.Operator.toLowerCase() === CompareOperators.AUTO.toLowerCase()) {\r\n            const searchableColumns = request.Columns.filter((x: any) => x.Searchable);\r\n\r\n            if (searchableColumns.length > 0) {\r\n                const filter = request.Search.Text.toLowerCase();\r\n                if (filter === '') { return subset; }\r\n\r\n                return subset.filter((item) =>\r\n                    searchableColumns.some((x: any) => {\r\n                        if (typeof item[x.Name] === 'undefined') {\r\n                            return false;\r\n                        } else {\r\n                            return item[x.Name].toLowerCase().indexOf(filter) > -1;\r\n                        }\r\n                    }));\r\n            }\r\n\r\n            return subset;\r\n        }\r\n    }\r\n\r\n    private static applyFiltering(request: GridRequest, subset: any[]) {\r\n        request.Columns\r\n            .filter((column: ColumnModel) => column.hasFilter)\r\n            .forEach((column: ColumnModel) => {\r\n                const isDate = column.DataType === 'datetime' ||\r\n                    column.DataType === 'date' ||\r\n                    column.DataType === 'datetimeutc';\r\n\r\n                const partialfiltering = (data: any[], action: (f: string) => boolean) => data.filter(\r\n                    (row: any) => typeof row[column.Name] === 'undefined' || row[column.Name] === null\r\n                        ? false\r\n                        : action(row[column.Name]));\r\n\r\n                switch (column.Filter.Operator) {\r\n                    case CompareOperators.EQUALS:\r\n                        if (isDate) {\r\n                            subset = subset.filter((row) =>\r\n                                isEqual(row[column.Name], column.Filter.Text));\r\n                        } else if (column.DataType === 'string') {\r\n                            subset = partialfiltering(subset,\r\n                                (x: string) => x.toLowerCase() === column.Filter.Text.toLowerCase());\r\n                        } else {\r\n                            subset = subset.filter((row) =>\r\n                                row[column.Name] === column.Filter.Text);\r\n                        }\r\n                        break;\r\n                    case CompareOperators.NOT_EQUALS:\r\n                        if (column.DataType === 'string') {\r\n                            subset = partialfiltering(subset,\r\n                                (x: string) => x.toLowerCase() !== column.Filter.Text.toLowerCase());\r\n                        } else {\r\n                            subset = subset.filter((row) =>\r\n                                row[column.Name] !== column.Filter.Text);\r\n                        }\r\n                        break;\r\n                    case CompareOperators.CONTAINS:\r\n                        subset = partialfiltering(subset, (x) => x.toLowerCase()\r\n                            .indexOf(column.Filter.Text.toLowerCase()) >= 0);\r\n                        subset = partialfiltering(subset,\r\n                            (x: string) => x.toLowerCase().indexOf(column.Filter.Text.toLowerCase()) >= 0);\r\n                        break;\r\n                    case CompareOperators.NOT_CONTAINS:\r\n                        subset = partialfiltering(subset,\r\n                            (x: string) => x.toLowerCase().indexOf(column.Filter.Text.toLowerCase()) < 0);\r\n                        break;\r\n                    case CompareOperators.STARTS_WITH:\r\n                        subset = partialfiltering(subset,\r\n                            (x: string) => x.toLowerCase().startsWith(column.Filter.Text.toLowerCase()));\r\n                        break;\r\n                    case CompareOperators.NOT_STARTS_WITH:\r\n                        subset = partialfiltering(subset,\r\n                            (x: string) => !x.toLowerCase().startsWith(column.Filter.Text.toLowerCase()));\r\n                        break;\r\n                    case CompareOperators.ENDS_WITH:\r\n                        subset = partialfiltering(subset,\r\n                            (x: string) => x.toLowerCase().endsWith(column.Filter.Text.toLowerCase()));\r\n                    case CompareOperators.NOT_ENDS_WITH:\r\n                        subset = partialfiltering(subset,\r\n                            (x: string) => !x.toLowerCase().endsWith(column.Filter.Text.toLowerCase()));\r\n                        break;\r\n                    case CompareOperators.GT:\r\n                        if (isDate) {\r\n                            subset = subset.filter((row) =>\r\n                                isAfter(row[column.Name], column.Filter.Text));\r\n                        } else {\r\n                            subset = subset.filter((row) => row[column.Name] > column.Filter.Text);\r\n                        }\r\n                        break;\r\n                    case CompareOperators.GTE:\r\n                        if (isDate) {\r\n                            subset = subset.filter((row) =>\r\n                                isEqual(row[column.Name], column.Filter.Text)\r\n                                || isAfter(row[column.Name], column.Filter.Text));\r\n                        } else {\r\n                            subset = subset.filter((row) => row[column.Name] >= column.Filter.Text);\r\n                        }\r\n                        break;\r\n                    case CompareOperators.LT:\r\n                        if (isDate) {\r\n                            subset = subset.filter((row) =>\r\n                                isBefore(row[column.Name], column.Filter.Text));\r\n                        } else {\r\n                            subset = subset.filter((row) => row[column.Name] < column.Filter.Text);\r\n                        }\r\n                        break;\r\n                    case CompareOperators.LTE:\r\n                        if (isDate) {\r\n                            subset = subset.filter((row) =>\r\n                                isEqual(row[column.Name], column.Filter.Text)\r\n                                || isBefore(row[column.Name], column.Filter.Text));\r\n                        } else {\r\n                            subset = subset.filter((row) => row[column.Name] <= column.Filter.Text);\r\n                        }\r\n                        break;\r\n                    case CompareOperators.BETWEEN:\r\n                        if (isDate) {\r\n                            subset = subset.filter((row) =>\r\n                                (isEqual(row[column.Name], column.Filter.Text)\r\n                                    || isAfter(row[column.Name], column.Filter.Text)) &&\r\n                                (isEqual(row[column.Name], column.Filter.Argument[0])\r\n                                    || isBefore(row[column.Name], column.Filter.Argument[0])));\r\n                        } else {\r\n                            subset = subset.filter((row) => row[column.Name] >= column.Filter.Text &&\r\n                                row[column.Name] <= column.Filter.Argument[0]);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        throw new Error('Unsupported Compare Operator');\r\n                }\r\n            });\r\n\r\n        return subset;\r\n    }\r\n\r\n    private static applySorting(request: GridRequest, subset: any[]) {\r\n        const sortedColumns = request.Columns\r\n            .filter((column: ColumnModel) => column.SortOrder > 0);\r\n\r\n        let sorts: any[] = [\r\n            { Name: request.Columns[0].Name, Asc: true }\r\n        ];\r\n\r\n        if (sortedColumns.length > 0) {\r\n            sortedColumns.sort((a, b) => a.SortOrder > b.SortOrder ? 1 : b.SortOrder > a.SortOrder ? -1 : 0);\r\n\r\n            sorts = sortedColumns\r\n                .map((y: ColumnModel) => ({ Name: y.Name, Asc: y.SortDirection === ColumnSortDirection.ASCENDING }));\r\n        }\r\n\r\n        subset.sort((a, b) => {\r\n            let result = 0;\r\n\r\n            for (const current of sorts) {\r\n                const reverse = current.Asc ? 1 : -1;\r\n\r\n                if (typeof a[current.Name] === 'undefined' || typeof b[current.Name] === 'undefined') {\r\n                    result = reverse * -1;\r\n                    break;\r\n                }\r\n\r\n                if (a[current.Name] < b[current.Name]) {\r\n                    result = reverse * -1;\r\n                    break;\r\n                }\r\n                if (a[current.Name] > b[current.Name]) {\r\n                    result = reverse * 1;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        });\r\n\r\n        return subset;\r\n    }\r\n\r\n    private static getAggregatePayload(request: GridRequest, subset: any[]) {\r\n        const aggregateColumns = request.Columns\r\n            .filter((column: ColumnModel) =>\r\n                column.Aggregate && column.Aggregate.toLowerCase() !== AggregateFunctions.NONE.toLowerCase());\r\n\r\n        return aggregateColumns.reduce((prev: any, column: ColumnModel) => {\r\n            switch (column.Aggregate.toLowerCase()) {\r\n                case AggregateFunctions.SUM.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0\r\n                        ? 0\r\n                        : subset.reduce((sum, r) => typeof r[column.Name] === 'undefined'\r\n                            ? sum\r\n                            : sum + r[column.Name], 0);\r\n                    break;\r\n                case AggregateFunctions.AVERAGE.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0\r\n                        ? 0\r\n                        : subset.reduce((sum, r) => typeof r[column.Name] === 'undefined'\r\n                            ? sum\r\n                            : sum + r[column.Name], 0)\r\n                        / subset.length;\r\n                    break;\r\n                case AggregateFunctions.MAX.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0 ? 0\r\n                        : subset.reduce((max, r) => r[column.Name] > max ? r[column.Name] : max,\r\n                            subset[0][column.Name]);\r\n                    break;\r\n                case AggregateFunctions.MIN.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0 ? 0\r\n                        : subset.reduce((min, r) => r[column.Name] < min ? r[column.Name] : min,\r\n                            subset[0][column.Name]);\r\n                    break;\r\n                case AggregateFunctions.COUNT.toLowerCase():\r\n                    prev[column.Name] = subset.length;\r\n                    break;\r\n                case AggregateFunctions.DISTINCT_COUNT.toLowerCase():\r\n                    prev[column.Name] = subset.length === 0 ? 0\r\n                        : subset.reduce((list, r) => {\r\n                            if (list.indexOf(r[column.Name]) === -1) { list.push(r[column.Name]); }\r\n                            return list;\r\n                        }, []).length;\r\n                    break;\r\n                default:\r\n                    throw new Error('Unsupported aggregate function');\r\n            }\r\n\r\n            return prev;\r\n        }, {});\r\n    }\r\n\r\n    private static parsePayload(row: any, columns: ColumnModel[]) {\r\n        return columns.reduce((obj: any, column: ColumnModel, key: number) => {\r\n            obj[column.Name] = row[key] || row[column.Name];\r\n\r\n            return obj;\r\n        }, {});\r\n    }\r\n}\r\n"]}},"error":null,"hash":"f8c583cde4b6f78a67dd7ad6660e8ec4","cacheData":{"env":{}}}